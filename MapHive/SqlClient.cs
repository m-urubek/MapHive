using System;
using System.Collections.Concurrent;
using System.Data;
using System.Data.SQLite;
using System.Threading;
using System.Threading.Tasks;

public class SqlClient
{
    private readonly string _connectionString;
    
    // This semaphore ensures only one operation executes at a time
    private static readonly SemaphoreSlim _semaphore = new SemaphoreSlim(1, 1);
    
    // Queue to track pending operations - useful for debugging and monitoring
    private static readonly ConcurrentQueue<string> _operationsQueue = new ConcurrentQueue<string>();

    public SqlClient(string databaseFilePath)
    {
        if (string.IsNullOrEmpty(databaseFilePath))
        {
            throw new ArgumentException("Database file path cannot be null or empty.", nameof(databaseFilePath));
        }

        this._connectionString = $"Data Source={databaseFilePath};Version=3;";
    }

    /// <summary>
    /// Executes an INSERT query and returns the autogenerated ID of the inserted row.
    /// </summary>
    /// <param name="query">The SQL query string to execute (INSERT).</param>
    /// <param name="parameters">An array of SQLite parameters to use in the query.</param>
    /// <returns>The autogenerated ID of the inserted row.</returns>
    public int Insert(string query, SQLiteParameter[]? parameters = null)
    {
        return InsertAsync(query, parameters).GetAwaiter().GetResult();
    }
    
    /// <summary>
    /// Asynchronously executes an INSERT query and returns the autogenerated ID of the inserted row.
    /// </summary>
    /// <param name="query">The SQL query string to execute (INSERT).</param>
    /// <param name="parameters">An array of SQLite parameters to use in the query.</param>
    /// <returns>A task that represents the asynchronous operation. The task result contains the autogenerated ID.</returns>
    public async Task<int> InsertAsync(string query, SQLiteParameter[]? parameters = null)
    {
        if (string.IsNullOrEmpty(query))
        {
            throw new ArgumentException("Query cannot be null or empty.", nameof(query));
        }
        
        string operationId = Guid.NewGuid().ToString();
        _operationsQueue.Enqueue($"INSERT {operationId}");
        
        // Wait until it's this operation's turn
        await _semaphore.WaitAsync();
        try
        {
            using SQLiteConnection connection = new(this._connectionString);
            await connection.OpenAsync();
            using SQLiteCommand command = new(query, connection);
            if (parameters != null)
            {
                command.Parameters.AddRange(parameters);
            }

            _ = await command.ExecuteNonQueryAsync();

            // Use the connection to get the last inserted row ID
            return Convert.ToInt32(connection.LastInsertRowId);
        }
        finally
        {
            // Operation complete, remove from queue and release the semaphore
            string dequeued;
            _operationsQueue.TryDequeue(out dequeued);
            _semaphore.Release();
        }
    }

    /// <summary>
    /// Executes an UPDATE query and returns the number of rows affected.
    /// </summary>
    /// <param name="query">The SQL query string to execute (UPDATE).</param>
    /// <param name="parameters">An array of SQLite parameters to use in the query.</param>
    /// <returns>The number of rows affected by the query.</returns>
    public int Update(string query, SQLiteParameter[]? parameters = null)
    {
        return UpdateAsync(query, parameters).GetAwaiter().GetResult();
    }
    
    /// <summary>
    /// Asynchronously executes an UPDATE query and returns the number of rows affected.
    /// </summary>
    /// <param name="query">The SQL query string to execute (UPDATE).</param>
    /// <param name="parameters">An array of SQLite parameters to use in the query.</param>
    /// <returns>A task that represents the asynchronous operation. The task result contains the number of rows affected.</returns>
    public async Task<int> UpdateAsync(string query, SQLiteParameter[]? parameters = null)
    {
        if (string.IsNullOrEmpty(query))
        {
            throw new ArgumentException("Query cannot be null or empty.", nameof(query));
        }
        
        string operationId = Guid.NewGuid().ToString();
        _operationsQueue.Enqueue($"UPDATE {operationId}");
        
        await _semaphore.WaitAsync();
        try
        {
            using SQLiteConnection connection = new(this._connectionString);
            await connection.OpenAsync();
            using SQLiteCommand command = new(query, connection);
            if (parameters != null)
            {
                command.Parameters.AddRange(parameters);
            }

            return await command.ExecuteNonQueryAsync();  // Return the number of affected rows
        }
        finally
        {
            string dequeued;
            _operationsQueue.TryDequeue(out dequeued);
            _semaphore.Release();
        }
    }

    /// <summary>
    /// Executes a SELECT query and returns the result as a DataTable.
    /// </summary>
    /// <param name="query">The SQL query string to execute (SELECT).</param>
    /// <param name="parameters">An array of SQLite parameters to use in the query.</param>
    /// <returns>A DataTable containing the query results.</returns>
    public DataTable Select(string query, SQLiteParameter[]? parameters = null)
    {
        return SelectAsync(query, parameters).GetAwaiter().GetResult();
    }
    
    /// <summary>
    /// Asynchronously executes a SELECT query and returns the result as a DataTable.
    /// </summary>
    /// <param name="query">The SQL query string to execute (SELECT).</param>
    /// <param name="parameters">An array of SQLite parameters to use in the query.</param>
    /// <returns>A task that represents the asynchronous operation. The task result contains a DataTable with the query results.</returns>
    public async Task<DataTable> SelectAsync(string query, SQLiteParameter[]? parameters = null)
    {
        if (string.IsNullOrEmpty(query))
        {
            throw new ArgumentException("Query cannot be null or empty.", nameof(query));
        }
        
        string operationId = Guid.NewGuid().ToString();
        _operationsQueue.Enqueue($"SELECT {operationId}");
        
        await _semaphore.WaitAsync();
        try
        {
            using SQLiteConnection connection = new(this._connectionString);
            await connection.OpenAsync();
            using SQLiteCommand command = new(query, connection);
            if (parameters != null)
            {
                command.Parameters.AddRange(parameters);
            }

            using SQLiteDataAdapter adapter = new(command);
            DataTable dataTable = new();
            adapter.Fill(dataTable); // Note: SQLiteDataAdapter doesn't have async methods
            return dataTable;  // Return the result set as DataTable
        }
        finally
        {
            string dequeued;
            _operationsQueue.TryDequeue(out dequeued);
            _semaphore.Release();
        }
    }

    /// <summary>
    /// Executes a DELETE query and returns the number of rows affected.
    /// </summary>
    /// <param name="query">The SQL query string to execute (DELETE).</param>
    /// <param name="parameters">An array of SQLite parameters to use in the query.</param>
    /// <returns>The number of rows affected by the query.</returns>
    public int Delete(string query, SQLiteParameter[]? parameters = null)
    {
        return DeleteAsync(query, parameters).GetAwaiter().GetResult();
    }
    
    /// <summary>
    /// Asynchronously executes a DELETE query and returns the number of rows affected.
    /// </summary>
    /// <param name="query">The SQL query string to execute (DELETE).</param>
    /// <param name="parameters">An array of SQLite parameters to use in the query.</param>
    /// <returns>A task that represents the asynchronous operation. The task result contains the number of rows affected.</returns>
    public async Task<int> DeleteAsync(string query, SQLiteParameter[]? parameters = null)
    {
        if (string.IsNullOrEmpty(query))
        {
            throw new ArgumentException("Query cannot be null or empty.", nameof(query));
        }
        
        string operationId = Guid.NewGuid().ToString();
        _operationsQueue.Enqueue($"DELETE {operationId}");
        
        await _semaphore.WaitAsync();
        try
        {
            using SQLiteConnection connection = new(this._connectionString);
            await connection.OpenAsync();
            using SQLiteCommand command = new(query, connection);
            if (parameters != null)
            {
                command.Parameters.AddRange(parameters);
            }

            return await command.ExecuteNonQueryAsync();  // Return the number of rows affected
        }
        finally
        {
            string dequeued;
            _operationsQueue.TryDequeue(out dequeued);
            _semaphore.Release();
        }
    }

    /// <summary>
    /// Executes an ALTER query and returns the number of rows affected.
    /// </summary>
    /// <param name="query">The SQL query string to execute (ALTER).</param>
    /// <param name="parameters">An array of SQLite parameters to use in the query.</param>
    /// <returns>The number of rows affected by the query.</returns>
    public int Alter(string query, SQLiteParameter[]? parameters = null)
    {
        return AlterAsync(query, parameters).GetAwaiter().GetResult();
    }
    
    /// <summary>
    /// Asynchronously executes an ALTER query and returns the number of rows affected.
    /// </summary>
    /// <param name="query">The SQL query string to execute (ALTER).</param>
    /// <param name="parameters">An array of SQLite parameters to use in the query.</param>
    /// <returns>A task that represents the asynchronous operation. The task result contains the number of rows affected.</returns>
    public async Task<int> AlterAsync(string query, SQLiteParameter[]? parameters = null)
    {
        if (string.IsNullOrEmpty(query))
        {
            throw new ArgumentException("Query cannot be null or empty.", nameof(query));
        }
        
        string operationId = Guid.NewGuid().ToString();
        _operationsQueue.Enqueue($"ALTER {operationId}");
        
        await _semaphore.WaitAsync();
        try
        {
            using SQLiteConnection connection = new(this._connectionString);
            await connection.OpenAsync();
            using SQLiteCommand command = new(query, connection);
            if (parameters != null)
            {
                command.Parameters.AddRange(parameters);
            }

            return await command.ExecuteNonQueryAsync();  // Return the number of rows affected
        }
        finally
        {
            string dequeued;
            _operationsQueue.TryDequeue(out dequeued);
            _semaphore.Release();
        }
    }
    
    /// <summary>
    /// Get the current number of operations in the queue.
    /// </summary>
    /// <returns>The number of operations currently queued</returns>
    public int GetQueueSize()
    {
        return _operationsQueue.Count;
    }
    
    /// <summary>
    /// Executes a custom query with the specified command behavior.
    /// </summary>
    /// <param name="query">The SQL query to execute.</param>
    /// <param name="parameters">Parameters for the query.</param>
    /// <param name="behavior">The command behavior to use.</param>
    /// <returns>The result of the query as an object.</returns>
    public object ExecuteCustomQuery(string query, SQLiteParameter[]? parameters = null, CommandBehavior behavior = CommandBehavior.Default)
    {
        return ExecuteCustomQueryAsync(query, parameters, behavior).GetAwaiter().GetResult();
    }
    
    /// <summary>
    /// Asynchronously executes a custom query with the specified command behavior.
    /// </summary>
    /// <param name="query">The SQL query to execute.</param>
    /// <param name="parameters">Parameters for the query.</param>
    /// <param name="behavior">The command behavior to use.</param>
    /// <returns>A task that represents the asynchronous operation. The task result contains the query result as an object.</returns>
    public async Task<object> ExecuteCustomQueryAsync(string query, SQLiteParameter[]? parameters = null, CommandBehavior behavior = CommandBehavior.Default)
    {
        if (string.IsNullOrEmpty(query))
        {
            throw new ArgumentException("Query cannot be null or empty.", nameof(query));
        }
        
        string operationId = Guid.NewGuid().ToString();
        _operationsQueue.Enqueue($"CUSTOM {operationId}");
        
        await _semaphore.WaitAsync();
        try
        {
            using SQLiteConnection connection = new(this._connectionString);
            await connection.OpenAsync();
            using SQLiteCommand command = new(query, connection);
            if (parameters != null)
            {
                command.Parameters.AddRange(parameters);
            }
            
            // Based on the beginning of the query, determine the appropriate execution method
            string queryStart = query.TrimStart().ToUpper();
            
            if (queryStart.StartsWith("SELECT"))
            {
                using var reader = await command.ExecuteReaderAsync(behavior);
                DataTable dataTable = new();
                dataTable.Load(reader);
                return dataTable;
            }
            else if (queryStart.StartsWith("INSERT"))
            {
                await command.ExecuteNonQueryAsync();
                return Convert.ToInt32(connection.LastInsertRowId);
            }
            else
            {
                return await command.ExecuteNonQueryAsync();
            }
        }
        finally
        {
            string dequeued;
            _operationsQueue.TryDequeue(out dequeued);
            _semaphore.Release();
        }
    }
}
