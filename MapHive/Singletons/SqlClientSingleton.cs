using MapHive.Models.Enums;
using System.Collections.Concurrent;
using System.Data;
using System.Data.SQLite;
using System.Security.Cryptography;
using System.Text;

namespace MapHive.Singletons
{
    public class SqlClientSingleton : ISqlClientSingleton
    {
        private readonly IFileLoggerSingleton _fileLoggerSingleton;

        private readonly string _connectionString;

        // This semaphore ensures only one operation executes at a time
        private static readonly SemaphoreSlim _semaphore = new(1, 1);

        // Queue to track pending operations - useful for debugging and monitoring
        private static readonly ConcurrentQueue<string> _operationsQueue = new();

        public SqlClientSingleton(IFileLoggerSingleton fileLogger)
        {
            this._fileLoggerSingleton = fileLogger;
            // Determine the correct path based on environment/deployment needs.
            // Consider using configuration for the database path.
            string databaseFilePath = "D:\\MapHive\\MapHive\\maphive.db"; // Development path
            if (!File.Exists(databaseFilePath))
            {
                // Fallback for production or different environments
                databaseFilePath = Path.Combine(AppContext.BaseDirectory, "maphive.db");
            }
            // Ensure the directory exists (important for first run)
            string? directory = Path.GetDirectoryName(databaseFilePath);
            if (directory != null && !Directory.Exists(directory))
            {
                _ = Directory.CreateDirectory(directory);
            }

            if (string.IsNullOrEmpty(databaseFilePath))
            {
                throw new ArgumentException("Database file path cannot be null or empty.", nameof(databaseFilePath));
            }
            this._connectionString = $"Data Source={databaseFilePath};Version=3;";
            if (!File.Exists(databaseFilePath))
            {
                SQLiteConnection.CreateFile(databaseFilePath);
                _ = this.ApplyEmptySchema(databaseFilePath);
            }
        }

        /// <summary>
        /// Asynchronously executes an INSERT query and returns the autogenerated ID of the inserted row.
        /// </summary>
        /// <param name="query">The SQL query string to execute (INSERT).</param>
        /// <param name="parameters">An array of SQLite parameters to use in the query.</param>
        /// <returns>A task that represents the asynchronous operation. The task result contains the autogenerated ID.</returns>
        public async Task<int> InsertAsync(string query, SQLiteParameter[]? parameters = null)
        {
            if (string.IsNullOrEmpty(query))
            {
                throw new ArgumentException("Query cannot be null or empty.", nameof(query));
            }

            string operationId = Guid.NewGuid().ToString();
            _operationsQueue.Enqueue($"INSERT {operationId}");

            // Wait until it's this operation's turn
            await _semaphore.WaitAsync();
            try
            {
                using SQLiteConnection connection = new(this._connectionString);
                await connection.OpenAsync();
                using SQLiteCommand command = new(query, connection);
                if (parameters != null)
                {
                    command.Parameters.AddRange(parameters);
                }

                _ = await command.ExecuteNonQueryAsync();

                // Use the connection to get the last inserted row ID
                return Convert.ToInt32(connection.LastInsertRowId);
            }
            finally
            {
                // Operation complete, remove from queue and release the semaphore
                _ = _operationsQueue.TryDequeue(out _);
                _ = _semaphore.Release();
            }
        }

        /// <summary>
        /// Asynchronously executes an UPDATE query and returns the number of rows affected.
        /// </summary>
        /// <param name="query">The SQL query string to execute (UPDATE).</param>
        /// <param name="parameters">An array of SQLite parameters to use in the query.</param>
        /// <returns>A task that represents the asynchronous operation. The task result contains the number of rows affected.</returns>
        public async Task<int> UpdateAsync(string query, SQLiteParameter[]? parameters = null)
        {
            if (string.IsNullOrEmpty(query))
            {
                throw new ArgumentException("Query cannot be null or empty.", nameof(query));
            }

            string operationId = Guid.NewGuid().ToString();
            _operationsQueue.Enqueue($"UPDATE {operationId}");

            await _semaphore.WaitAsync();
            try
            {
                using SQLiteConnection connection = new(this._connectionString);
                await connection.OpenAsync();
                using SQLiteCommand command = new(query, connection);
                if (parameters != null)
                {
                    command.Parameters.AddRange(parameters);
                }

                return await command.ExecuteNonQueryAsync();  // Return the number of affected rows
            }
            finally
            {
                _ = _operationsQueue.TryDequeue(out _);
                _ = _semaphore.Release();
            }
        }

        /// <summary>
        /// Asynchronously executes a SELECT query and returns the result as a DataTable.
        /// </summary>
        /// <param name="query">The SQL query string to execute (SELECT).</param>
        /// <param name="parameters">An array of SQLite parameters to use in the query.</param>
        /// <returns>A task that represents the asynchronous operation. The task result contains a DataTable with the query results.</returns>
        public async Task<DataTable> SelectAsync(string query, SQLiteParameter[]? parameters = null)
        {
            if (string.IsNullOrEmpty(query))
            {
                throw new ArgumentException("Query cannot be null or empty.", nameof(query));
            }

            string operationId = Guid.NewGuid().ToString();
            _operationsQueue.Enqueue($"SELECT {operationId}");

            await _semaphore.WaitAsync();
            try
            {
                using SQLiteConnection connection = new(this._connectionString);
                await connection.OpenAsync();
                using SQLiteCommand command = new(query, connection);
                if (parameters != null)
                {
                    command.Parameters.AddRange(parameters);
                }

                using SQLiteDataAdapter adapter = new(command);
                DataTable dataTable = new();
                _ = adapter.Fill(dataTable); // Note: SQLiteDataAdapter doesn't have async methods
                return dataTable;  // Return the result set as DataTable
            }
            finally
            {
                _ = _operationsQueue.TryDequeue(out _);
                _ = _semaphore.Release();
            }
        }

        /// <summary>
        /// Asynchronously executes a DELETE query and returns the number of rows affected.
        /// </summary>
        /// <param name="query">The SQL query string to execute (DELETE).</param>
        /// <param name="parameters">An array of SQLite parameters to use in the query.</param>
        /// <returns>A task that represents the asynchronous operation. The task result contains the number of rows affected.</returns>
        public async Task<int> DeleteAsync(string query, SQLiteParameter[]? parameters = null)
        {
            if (string.IsNullOrEmpty(query))
            {
                throw new ArgumentException("Query cannot be null or empty.", nameof(query));
            }

            string operationId = Guid.NewGuid().ToString();
            _operationsQueue.Enqueue($"DELETE {operationId}");

            await _semaphore.WaitAsync();
            try
            {
                using SQLiteConnection connection = new(this._connectionString);
                await connection.OpenAsync();
                using SQLiteCommand command = new(query, connection);
                if (parameters != null)
                {
                    command.Parameters.AddRange(parameters);
                }

                return await command.ExecuteNonQueryAsync();  // Return the number of affected rows
            }
            finally
            {
                _ = _operationsQueue.TryDequeue(out _);
                _ = _semaphore.Release();
            }
        }

        /// <summary>
        /// Asynchronously executes an ALTER query or other schema-changing SQL statement and returns the number of rows affected.
        /// </summary>
        /// <param name="query">The SQL query string to execute (ALTER, CREATE, etc.).</param>
        /// <param name="parameters">An array of SQLite parameters to use in the query.</param>
        /// <returns>A task that represents the asynchronous operation. The task result contains the number of rows affected.</returns>
        public async Task<int> AlterAsync(string query, SQLiteParameter[]? parameters = null)
        {
            if (string.IsNullOrEmpty(query))
            {
                throw new ArgumentException("Query cannot be null or empty.", nameof(query));
            }

            string operationId = Guid.NewGuid().ToString();
            _operationsQueue.Enqueue($"ALTER {operationId}");

            await _semaphore.WaitAsync();
            try
            {
                using SQLiteConnection connection = new(this._connectionString);
                await connection.OpenAsync();
                using SQLiteCommand command = new(query, connection);
                if (parameters != null)
                {
                    command.Parameters.AddRange(parameters);
                }

                return await command.ExecuteNonQueryAsync();  // Return the number of rows affected
            }
            finally
            {
                _ = _operationsQueue.TryDequeue(out _);
                _ = _semaphore.Release();
            }
        }

        /// <summary>
        /// Get the current number of operations in the queue.
        /// </summary>
        /// <returns>The number of operations currently queued</returns>
        public int GetQueueSize()
        {
            return _operationsQueue.Count;
        }

        /// <summary>
        /// Asynchronously executes a custom query with the specified command behavior.
        /// </summary>
        /// <param name="query">The SQL query to execute.</param>
        /// <param name="parameters">Parameters for the query.</param>
        /// <param name="behavior">The command behavior to use.</param>
        /// <returns>A task that represents the asynchronous operation. The task result contains the query result as an object.</returns>
        public async Task<object> ExecuteCustomQueryAsync(string query, SQLiteParameter[]? parameters = null, CommandBehavior behavior = CommandBehavior.Default)
        {
            if (string.IsNullOrEmpty(query))
            {
                throw new ArgumentException("Query cannot be null or empty.", nameof(query));
            }

            string operationId = Guid.NewGuid().ToString();
            _operationsQueue.Enqueue($"CUSTOM {operationId}");

            await _semaphore.WaitAsync();
            try
            {
                using SQLiteConnection connection = new(this._connectionString);
                await connection.OpenAsync();
                using SQLiteCommand command = new(query, connection);
                if (parameters != null)
                {
                    command.Parameters.AddRange(parameters);
                }

                // Based on the beginning of the query, determine the appropriate execution method
                string queryStart = query.TrimStart().ToUpper();

                if (queryStart.StartsWith("SELECT"))
                {
                    using System.Data.Common.DbDataReader reader = await command.ExecuteReaderAsync(behavior);
                    DataTable dataTable = new();
                    dataTable.Load(reader);
                    return dataTable;
                }
                else if (queryStart.StartsWith("INSERT"))
                {
                    _ = await command.ExecuteNonQueryAsync();
                    return Convert.ToInt32(connection.LastInsertRowId);
                }
                else
                {
                    return await command.ExecuteNonQueryAsync();
                }
            }
            finally
            {
                _ = _operationsQueue.TryDequeue(out _);
                _ = _semaphore.Release();
            }
        }

        /// <summary>
        /// Asynchronously executes a SQL script that may contain multiple SQL statements separated by semicolons.
        /// </summary>
        /// <param name="sqlScript">The SQL script to execute, which may contain multiple statements.</param>
        /// <returns>A task that represents the asynchronous operation. The task result contains the number of statements successfully executed.</returns>
        public async Task<int> ExecuteScriptAsync(string sqlScript)
        {
            if (string.IsNullOrEmpty(sqlScript))
            {
                throw new ArgumentException("SQL script cannot be null or empty.", nameof(sqlScript));
            }

            string operationId = Guid.NewGuid().ToString();
            _operationsQueue.Enqueue($"SCRIPT {operationId}");

            await _semaphore.WaitAsync();
            try
            {
                using SQLiteConnection connection = new(this._connectionString);
                await connection.OpenAsync();

                // Split the script into individual statements
                string[] statements = sqlScript
                    .Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries)
                    .Where(s => !string.IsNullOrWhiteSpace(s))
                    .Select(s => s.Trim())
                    .ToArray();

                int executedStatements = 0;

                // Execute each statement
                foreach (string statement in statements)
                {
                    if (string.IsNullOrWhiteSpace(statement))
                    {
                        continue;
                    }

                    using SQLiteCommand command = new(statement, connection);
                    _ = await command.ExecuteNonQueryAsync();
                    executedStatements++;
                }

                return executedStatements;
            }
            finally
            {
                _ = _operationsQueue.TryDequeue(out string dequeued);
                _ = _semaphore.Release();
            }
        }

        private async Task ApplyEmptySchema(string dbFilePath)
        {
            string dbPath = Path.Combine(Directory.GetCurrentDirectory(), dbFilePath);
            string sqlSchemaPath = Path.Combine(Directory.GetCurrentDirectory(), "maphive.db.sql");

            this.LogBeforeDbCreated($"Database file not found at {dbPath}. Creating and initializing schema...");

            if (!File.Exists(sqlSchemaPath))
            {
                this.LogBeforeDbCreated($"Database schema file not found at {sqlSchemaPath}. Cannot initialize database.");
                throw new FileNotFoundException("Database schema file not found.", sqlSchemaPath);
            }

            try
            {
                // Read the schema file
                string schemaSql = File.ReadAllText(sqlSchemaPath);

                _ = await this.ExecuteScriptAsync(schemaSql);
                Console.WriteLine("Database schema created successfully.");

                // Insert initial version number
                string insertVersionQuery = "INSERT INTO VersionNumber (Value) VALUES (0);";
                _ = await this.InsertAsync(insertVersionQuery, null);
                this.LogBeforeDbCreated("Initial version number (0) inserted.");

                // Add initial admin user
                await this.InsertInitialAdminUserAsync();
                this.LogBeforeDbCreated($"Initial admin user 'admin' created.");

            }
            catch (Exception ex)
            {
                this.LogBeforeDbCreated($"Failed to initialize database schema from {sqlSchemaPath}: {ex.Message}");
                throw;
            }
        }

        private async Task InsertInitialAdminUserAsync()
        {
            string adminUsername = "admin";
            string adminPassword = "admin"; // Plain text password
            string hashedPassword = this.HashPassword(adminPassword); // Hash the password
            DateTime registrationDate = DateTime.UtcNow;
            int adminTier = (int)UserTier.Admin; // Assuming UserTier is an enum and Admin maps to an int

            // Insert admin user
            string insertAdminQuery = @"
                INSERT INTO Users (Username, PasswordHash, RegistrationDate, Tier, IpAddressHistory)
                VALUES (@Username, @PasswordHash, @RegistrationDate, @Tier, @IpAddressHistory);
            ";
            SQLiteParameter[] adminParams = new[]
            {
                new SQLiteParameter("@Username", adminUsername),
                new SQLiteParameter("@PasswordHash", hashedPassword),
                new SQLiteParameter("@RegistrationDate", registrationDate),
                new SQLiteParameter("@Tier", adminTier),
                new SQLiteParameter("@IpAddressHistory", "INITIAL_SETUP")
            };
            _ = await this.InsertAsync(insertAdminQuery, adminParams);
        }

        // Helper method to hash password (copied from AuthService for simplicity here)
        // Consider refactoring to a shared utility if needed elsewhere
        private string HashPassword(string password)
        {
            // Normalize the password to ensure consistent hashing
            password = password.Normalize(System.Text.NormalizationForm.FormKD);

            using SHA256 sha256 = SHA256.Create();
            byte[] bytes = sha256.ComputeHash(Encoding.UTF8.GetBytes(password));

            // Use lowercase hex format to ensure consistency with AuthService
            StringBuilder builder = new();
            for (int i = 0; i < bytes.Length; i++)
            {
                _ = builder.Append(bytes[i].ToString("x2"));
            }

            // Return lowercase hex string
            return builder.ToString().ToLowerInvariant();
        }

        private void LogBeforeDbCreated(string logMessage)
        {
            this._fileLoggerSingleton.LogToFile(logMessage);
            Console.WriteLine(logMessage);
        }
    }
}
